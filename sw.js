const CACHE_NAME = 'ritual-cache-v1'; const urlsToCache = [ '/', '/index.html', '/style.css', '/script.js', '/icon.png', '/manifest.json', 'https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600&display=swap', 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css' ]; // Instalación del Service Worker self.addEventListener('install', event => { event.waitUntil( caches.open(CACHE_NAME) .then(cache => { console.log('Cache abierto'); return cache.addAll(urlsToCache); }) ); }); // Activación del Service Worker self.addEventListener('activate', event => { const cacheWhitelist = [CACHE_NAME]; event.waitUntil( caches.keys().then(cacheNames => { return Promise.all( cacheNames.map(cacheName => { if (cacheWhitelist.indexOf(cacheName) === -1) { return caches.delete(cacheName); } }) ); }) ); }); // Estrategia de caché: Cache First, luego Network self.addEventListener('fetch', event => { event.respondWith( caches.match(event.request) .then(response => { // Retorna el recurso desde la caché si existe if (response) { return response; } // Si no está en caché, solicitarlo a la red return fetch(event.request) .then(response => { // Verifica si la respuesta es válida if (!response || response.status !== 200 || response.type !== 'basic') { return response; } // Clonar la respuesta ya que vamos a usarla dos veces const responseToCache = response.clone(); // Guardar la nueva respuesta en caché caches.open(CACHE_NAME) .then(cache => { cache.put(event.request, responseToCache); }); return response; }); }) ); });
